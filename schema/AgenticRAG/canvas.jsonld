{
  "@context": "https://huijoohwee.github.io/schema/AgenticRAG/v1/context.jsonld",
  "@id": "rag:Canvas",
  "@type": "rag:Directive",
  "schemaVersion": "1.0.13",
  "rdfs:label": [
    { "@value": "Canvas integration directives", "@language": "en-us" },
    { "@value": "画布集成指令", "@language": "zh-cn" }
  ],
  "rdfs:comment": [
    {
      "@value": "Directive describing domain-agnostic integration contracts for Canvas render surfaces that consume AgenticRAG JSON-LD graphs. Focuses on order-safe import→render behavior, cache-key isolation, renderer exclusivity, and viewport-aware auto-fit so different renderers (2D/3D/Flow/Geospatial) do not drift or contaminate each other at runtime.",
      "@language": "en-us"
    },
    {
      "@value": "描述消费 AgenticRAG JSON-LD 图的 Canvas 渲染表面的领域无关集成契约。重点覆盖顺序安全的 import→render 行为、缓存 key 隔离、渲染器互斥，以及对 viewport 变化敏感的自适配（auto-fit），避免 2D/3D/Flow/Geospatial 等渲染器在运行时发生漂移或相互污染。",
      "@language": "zh-cn"
    }
  ],
  "canvasContracts": {
    "rendererExclusivity": [
      {
        "@value": "Only one renderer surface is active at a time (2D: D3/Flow/Flow Editor, 3D, Geospatial). The app may warm-mount inactive surfaces to reduce switch lag, but non-active surfaces must be effect-gated (no draw loops, no request consumption, no shared-cache writes). Switching renderer surfaces must preserve selection and view state via stable SSOT keys rather than duplicating computation.",
        "@language": "en-us"
      },
      {
        "@value": "任意时刻只允许一个渲染表面处于激活状态（2D：D3/Flow/Flow Editor，3D，Geospatial）。可为降低切换延迟而 warm-mount 非激活表面，但必须通过 effect gating 禁止其运行 draw loop、消费共享请求、或写入共享缓存。切换渲染表面需通过稳定的 SSOT key 保持选择与视图状态，禁止重复计算。",
        "@language": "zh-cn"
      }
    ],
    "viewKeyIsolation": [
      {
        "@value": "View state and caches are isolated by explicit keys. Zoom view state may be intentionally shared across 2D renderer variants to preserve viewport continuity, but layout caches must include renderer variant and other layout-affecting toggles. Avoid cross-mode contamination by never sharing layout caches between different layout keys.",
        "@language": "en-us"
      },
      {
        "@value": "视图状态与缓存必须通过显式 key 隔离：zoom 视图状态可在 2D 渲染器变体之间有意共享以保持 viewport 连续性，但布局缓存必须把渲染器变体与其他影响布局的开关纳入 key。不同布局 key 之间禁止共享布局缓存，以避免跨模式污染。",
        "@language": "zh-cn"
      }
    ],
    "layoutCacheKeyIsolation": [
      {
        "@value": "Layout caches (positions, seeds, bounding boxes) must include all layout-affecting inputs in their cache keys, including renderer variant and media-related toggles. When a renderer variant changes, the layout pipeline must treat it as a distinct variant and avoid reusing stale positioning from another renderer.",
        "@language": "en-us"
      },
      {
        "@value": "布局缓存（位置、seed、包围盒）必须在 cache key 中纳入所有影响布局的输入，包括渲染器变体与媒体相关开关。渲染器变体变化时，布局流水线必须视其为不同变体，禁止复用来自其他渲染器的过期定位结果。",
        "@language": "zh-cn"
      }
    ],
    "viewportAwareAutoFit": [
      {
        "@value": "Auto-fit/fit-to-screen must react to viewport dimension changes (including UI chrome changes such as sidebar/panel toggles). Auto-fit should be idempotent and should not fight user pinning; when view is pinned, auto-fit is suppressed until explicitly re-enabled.",
        "@language": "en-us"
      },
      {
        "@value": "自适配/铺满屏幕必须对 viewport 尺寸变化作出响应（包括侧边栏/面板开关等 UI chrome 变化）。自适配应幂等，且不得与用户的 pin 操作对抗；当视图被 pin 时，自适配应被抑制，直到用户显式重新启用。",
        "@language": "zh-cn"
      }
    ],
    "panZoomParity2d": [
      {
        "@value": "2D renderer variants (D3, Flow, Flow Editor) must share one SSOT mapping for viewport controls (preset + selection + wheel/trackpad/pinch zoom): consistent preset semantics (`viewportControlsPreset`: map vs design) for pan/zoom/select, wheel delta normalization, zoom sensitivity, and pointer-anchored zoom. Wheel/pinch zoom must be continuous (no discrete stepping) and may rAF-batch deltas; all renderers should apply a short anchored easing animation to avoid per-frame delta clumping and feel continuous; cancel on pan/drag and cleanup RAF on unmount. Trackpad pinch should be supported both as ctrl/meta wheel events and (where emitted) Safari `gesture*` events on canvas surfaces. Wheel pan must be consistent across renderers and apply the same pan speed composition (schema `panSpeed` × `flowWheelPanSpeedMultiplier`), independent of current zoom k. Zoom magnitude/increment, ctrl/meta pinch boost, pan speed multiplier, and smoothing durations may be user-tunable via MainPanel Settings (persisted) but must remain bounded; defaults may be upgraded once via a versioned persisted key to improve pinch responsiveness without overriding user-tuned values. Fit/Selection zoom action durations and zoom modes (pin/fit-to-screen/zoom-to-selection) may also be user-tunable and must be enforced consistently across all 2D renderers. Zoom-in/out commands (toolbar/keyboard) must scale about the current viewport center (preserve view center world point), while fit/reset may recenter on graph bounds/centroid. Node-attached overlays track the node world→screen position and may leave the viewport like nodes; detached overlays clamp in renderer viewport coordinates and must avoid post-paint snap-back that creates border bounce. When wheel events land slightly outside the viewport, clamp to the nearest edge before falling back to last-pointer or center to prevent border bounce. During active panning, zoom state commits must be rAF-throttled and may be interval-gated (and may be quantized) so overlays stay synced without end-of-pan snap; avoid anchor rounding that causes overlay shimmy. Prefer shared helpers for viewport clamping and pre-paint correction to prevent drift across surfaces. When the pointer is over the active canvas, prevent default page scroll/zoom so zooming never triggers horizontal/vertical page scrolling.",
        "@language": "en-us"
      },
      {
        "@value": "2D 渲染器变体（D3、Flow、Flow Editor）必须共享同一套 SSOT 的 viewport 控制映射（preset + 框选 + 滚轮/触控板/双指捏合缩放）：一致的 preset 语义（`viewportControlsPreset`: map vs design）用于 pan/zoom/select，一致的 delta 归一化、一致的缩放灵敏度、并以指针为锚点缩放。滚轮/捏合缩放必须是连续的（不允许离散分级跳变），可以做 rAF 批处理；所有渲染器都应使用短时的“以锚点为中心”的缓动动画，避免同一帧 delta 堆叠导致跳变并提升连续感；在平移/拖拽时必须取消，并在卸载时清理 RAF。缩放幅度/增量、Ctrl/Meta 捏合加速倍率与平滑时长可以在 MainPanel Settings 中由用户调参（持久化），但必须保持有界；默认值允许通过带版本的持久化 key 进行一次性升级，以提升捏合缩放响应且不得覆盖用户自定义值。Fit/Selection 的缩放动作时长与缩放模式（pin/fit-to-screen/zoom-to-selection）也可以由用户调参，并且必须在所有 2D 渲染器中一致强制执行。工具栏/键盘的 zoom-in/out 必须以当前 viewport 中心为锚点（保持视图中心对应的 world 点不变），而 fit/reset 可回到图的边界/重心。节点附着的 overlay 必须跟随节点 world→screen 位置并允许像节点一样离开 viewport；脱离（detached）overlay 必须使用渲染器 viewport 坐标系进行 clamp，并避免 post-paint 的“回弹修正”导致边界抖动。当滚轮事件略微落在 viewport 外侧时，必须先向边界 clamp，再回退到 last-pointer 或 center，以避免边缘回弹。平移进行中必须对 zoom state 做 rAF 节流且可做 interval gate（并可进行量化）提交，确保 overlay 与渲染器保持同步且不会在平移结束时出现 snap；避免锚点取整导致的 overlay 抖动。应优先复用共享的 viewport clamp 与 pre-paint 修正 helper，防止各表面实现漂移。当指针位于激活画布之上时，必须阻止页面默认滚动/缩放，确保缩放不会触发页面横向/纵向滚动。",
        "@language": "zh-cn"
      }
    ],
    "nodeEdgeVisibilityParity2d": [
      {
        "@value": "2D renderer variants (D3, Flow, Flow Editor) must apply the same node/edge display filter (visibility semantics) before layout, fit, and scene build. If a node is filtered out, all incident edges must also be filtered out; if the preferred filter would remove all nodes/edges, a safe fallback must display the base nodes/edges to avoid rendering an empty canvas. Initial view restoration must not apply stored transforms when graph bounds cannot be computed yet (e.g., no finite node positions); prefer fit/identity to prevent a blank view caused by stale offscreen pans.",
        "@language": "en-us"
      },
      {
        "@value": "2D 渲染器变体（D3、Flow、Flow Editor）必须在 layout / fit / scene build 之前应用同一套节点/边显示过滤（可见性语义）。若某节点被过滤掉，则其相连的所有边也必须被过滤掉；若“优先过滤”会导致节点/边全部被过滤，则必须使用安全回退策略显示基础节点/边，避免渲染为空。初始视图恢复时，若尚无法计算图边界（例如没有任何有限的节点坐标），不得应用持久化的 transform；应优先使用 fit/identity，避免因旧的离屏平移导致画布空白。",
        "@language": "zh-cn"
      }
    ],
    "panZoomParityGeospatial": [
      {
        "@value": "Geospatial mode must honor the same viewportControlsPreset semantics as 2D canvas surfaces. In map preset: slippy-map interactions are enabled (drag-pan, scroll/pinch zoom) and shift-drag may be reserved for box-zoom/selection without triggering pan. In design preset: wheel defaults to panning; zoom on wheel requires Ctrl/Cmd (trackpad pinch counts as zoom), and pointer-drag panning is restricted to middle/right drag or Space+drag. Interactions must be gated when the Geospatial surface is not active.",
        "@language": "en-us"
      },
      {
        "@value": "Geospatial 模式必须遵循与 2D 画布一致的 viewportControlsPreset 语义。map preset：开启类地图交互（拖拽平移、滚轮/捏合缩放），并将 Shift+拖拽保留为框选/box-zoom（不得触发平移）。design preset：滚轮默认用于平移；滚轮缩放需 Ctrl/Cmd（触控板捏合也视为缩放）；指针拖拽平移仅允许中键/右键拖拽或 Space+拖拽。Geospatial 表面非激活时必须对交互做 effect gating。",
        "@language": "zh-cn"
      }
    ],
    "overlayScrollIsolation2d": [
      {
        "@value": "Scrolling inside overlays (e.g., Flow Node Quick Editor) must not trigger canvas zoom. Mark overlays as wheel-ignore zones and make 2D wheel-zoom handlers early-return when the wheel event originates from (or the pointer is within) an ignore zone.",
        "@language": "en-us"
      },
      {
        "@value": "在 overlay 内滚动（例如 Flow Node Quick Editor）不得触发画布缩放。必须将 overlay 标记为 wheel-ignore zone，并让 2D 的 wheel-zoom handler 在事件来源于（或指针位于）ignore zone 时直接 return。",
        "@language": "zh-cn"
      }
    ],
    "overlayPointerCaptureSafety2d": [
      {
        "@value": "Overlays must opt out of forwarded canvas pan pointerdowns to prevent pointer-capture conflicts. If the Flow canvas loses pointer capture while a drag is active, it must cancel/clear the active drag state so wheel pan/zoom cannot become stuck or blocked.",
        "@language": "en-us"
      },
      {
        "@value": "Overlay 必须选择退出被转发到画布的“平移指针按下事件”，以避免 pointer capture 冲突。若 Flow 画布在拖拽过程中丢失 pointer capture，必须取消/清理当前 drag 状态，防止滚轮平移/缩放被卡死或被阻塞。",
        "@language": "zh-cn"
      }
    ],
    "interactionPerformance2d": [
      {
        "@value": "2D interaction handlers (wheel/pan/drag) must avoid forced layout reads and unnecessary rerenders. Prefer offset-based local coordinates (`offsetX/offsetY`) for canvas-local pointer/wheel mapping; only fall back to `getBoundingClientRect()` when offsets are unavailable. Avoid per-frame `getComputedStyle()`/CSS var reads in draw loops; cache theme tokens keyed by theme state. Imperative renderers should not subscribe to high-frequency store state (e.g., zoom state) in ways that rerender the React component on every commit.",
        "@language": "en-us"
      },
      {
        "@value": "2D 交互 handler（wheel/pan/drag）必须避免强制 layout 读取与不必要的 rerender。应优先使用基于 offset 的本地坐标（`offsetX/offsetY`）进行画布局部坐标映射；仅在 offset 不可用时回退到 `getBoundingClientRect()`。在 draw loop 中必须避免每帧执行 `getComputedStyle()`/CSS var 读取；应按主题状态 key 缓存 theme token。命令式渲染器不得订阅高频 store 状态（例如 zoom state）从而导致每次 commit 都触发 React 组件 rerender。",
        "@language": "zh-cn"
      }
    ],
    "collisionRelaxPerformance2d": [
      {
        "@value": "Collision relaxation during drag must be throttled (at most once per animation frame, and may be further time-bounded) and step-bounded. For large graphs, drag-time relaxation may be disabled to preserve interaction responsiveness; commit-time relaxation should use a size-aware step policy to stay bounded.",
        "@language": "en-us"
      },
      {
        "@value": "拖拽期间的碰撞 relax 必须被节流（最多每个动画帧一次，且可进一步按时间间隔限频）并限制 steps 上限。对于大图可禁用拖拽期 relax 以保证交互顺滑；commit 期 relax 必须使用与图规模相关的 steps 策略以保持有界。",
        "@language": "zh-cn"
      }
    ],
    "overlayRenderIsolation2d": [
      {
        "@value": "2D overlays that depend on zoom/pan for positioning (e.g., Node Quick Editor) must isolate zoom-dependent layout from heavy UI subtrees. Zoom updates should not re-render editor forms; prefer rAF-batched DOM style updates for position/scale and keep updates on the compositor path (e.g., `transform: translate3d(...) scale(...)` instead of left/top writes), and memoize the panel body.",
        "@language": "en-us"
      },
      {
        "@value": "依赖 zoom/pan 进行定位的 2D overlay（例如 Node Quick Editor）必须将与 zoom 相关的布局计算从重 UI 子树中隔离。zoom 更新不得触发 editor form rerender；应优先用 rAF 批处理的 DOM style 更新实现位置/缩放，并尽量走合成器路径（例如使用 `transform: translate3d(...) scale(...)` 而不是频繁写 left/top），并 memoize panel body。",
        "@language": "zh-cn"
      }
    ],
    "interactionNoTextSelectionDuringCanvasDrag": [
      {
        "@value": "During canvas pointer interactions (pan, drag, marquee) the app must prevent browser text selection and HTML dragstart side-effects so dragging never selects panel text or triggers copy/drag cursors.",
        "@language": "en-us"
      },
      {
        "@value": "在画布指针交互（平移、拖拽、框选）期间，应用必须阻止浏览器文本选择与 HTML dragstart 副作用，确保拖动不会选中面板文字或触发复制/拖拽光标。",
        "@language": "zh-cn"
      }
    ],
    "collisionNoStick": [
      {
        "@value": "Collision resolution must forbid exact-contact sticking: treat near-touch as overlap via a small touch-epsilon and enforce axis-aware spacing using sum-of-gaps (gapA + gapB) rather than max. Model boxes with indexed borders (inner x2..x4/y2..y4/z2..z4 vs outer envelope x1..x5/y1..y5/z1..z5); nested containment must compare child inner to parent outer. Z-axis resolution must be explicitly gated (non-zero cz, positive halfD, or positive explicit gapZ); otherwise treat Z as infinite overlap so 2D surfaces never accidentally push in Z.",
        "@language": "en-us"
      },
      {
        "@value": "碰撞消解必须禁止“贴边粘连”：通过 touch-epsilon 将近似接触视为重叠，并使用按轴间距的 sum-of-gaps（gapA + gapB）而不是 max 来保证更严格的分离。将盒子建模为带索引的边界（内边界 x2..x4/y2..y4/z2..z4 vs 外包络 x1..x5/y1..y5/z1..z5），嵌套包裹需对比子盒内边界与父盒外包络。Z 轴消解必须显式 gating（cz 非零、halfD 为正、或显式 gapZ 为正）；否则将 Z 视为无限重叠，确保 2D 表面不会误在 Z 轴上推挤。",
        "@language": "zh-cn"
      }
    ],
    "labelTextSsot": [
      {
        "@value": "Label wrapping/truncation and approximate text measurement must reuse one SSOT helper set across 2D renderers (D3, Flow, Flow Editor). Prefer cached, width-based truncation (estimate max chars from width + font size) over ad-hoc slice constants; avoid per-frame expensive text measurement loops. Label typography (font family/size/weight) must follow the UI design token SSOT so label behavior does not drift across surfaces.",
        "@language": "en-us"
      },
      {
        "@value": "Label 的换行/截断与近似文本度量必须在 2D 渲染器（D3、Flow、Flow Editor）之间复用同一套 SSOT helper。应优先使用带缓存的“按宽度截断”（根据 width + fontSize 估算最大字符数），禁止使用各表面自定义的 slice 常量；避免每帧执行昂贵的 text measurement 循环。Label 排版（字体族/字号/字重）必须遵循 UI 设计 token 的 SSOT，防止跨表面漂移。",
        "@language": "zh-cn"
      }
    ],
    "graphElementsSemantics": [
      {
        "@value": "Graph elements vocabulary: nodes (entities with id/label/type + properties), edges (relationships with id/source/target/label + properties), labels/text (rendered copy driven by SSOT UI tokens), and graph layers (groups/clusters/communities, selection, overlays). Node Quick Editor is a screen-space overlay anchored to a selected node and synchronized to world→screen transforms; its Key/Value grid uses In Port/Key/Type/Value/Out Port columns at 1%/29%/10%/59%/1%, shows port dots for every key row, aligns value inputs/selects via SSOT classes, and forbids horizontal scrolling. Node Quick Editor More actions are idempotent and SSOT-driven: enable Port Handles by setting schema.behavior.portHandles.enabled=true and schema.behavior.portHandles.showAllInputs=true; convert to Loop by setting node.type='Loop' and node.properties['workflow:kind']='loop'; open sidepane dispatches the panel open event without mutating GraphData. Edges may bind to explicit ports via edge.properties['flow:sourcePortKey'|'flow:targetPortKey']; schema-field ports are defined by node.properties['schema:fields'] and use port keys like field:<id>. When schema fields are edited in Node Quick Editor, renaming a field must rewrite any port-bound edges and recompute flow:displayLabel. Port-bound edges may provide a UI label override via edge.properties['flow:displayLabel'] and may be validated against schema endpoints + field-type compatibility. Node Quick Editor dataflow computes connectedValuesBySchemaPath across upstream chains without mutating GraphData; registry schemaMappings may specify reduceId and transformId to derive mapped values, and auto-apply fills only empty fields on demand or when enabled.",
        "@language": "en-us"
      },
      {
        "@value": "图元素词汇：nodes（包含 id/label/type 与 properties 的实体）、edges（包含 id/source/target/label 与 properties 的关系）、labels/text（由 SSOT UI token 驱动的渲染文案）、graph layers（groups/clusters/communities、selection、overlays）。Node Quick Editor 是屏幕空间的覆层，锚定选中节点并与 world→screen 变换保持同步；其 Key/Value 栅格使用 In Port/Key/Type/Value/Out Port 五列（1%/29%/10%/59%/1%），每行都显示端口点位，Value 输入/选择通过 SSOT 类对齐边框，并禁止横向滚动。Node Quick Editor 的 More actions 必须幂等并遵循 SSOT：通过设置 schema.behavior.portHandles.enabled=true 与 schema.behavior.portHandles.showAllInputs=true 启用 Port Handles；通过设置 node.type='Loop' 与 node.properties['workflow:kind']='loop' 转换为 Loop；打开 sidepane 仅派发面板打开事件且不得修改 GraphData。Edges 可通过 edge.properties['flow:sourcePortKey'|'flow:targetPortKey'] 绑定到显式端口；schema-field 端口由 node.properties['schema:fields'] 定义，并使用形如 field:<id> 的 port key。当在 Node Quick Editor 中编辑 schema 字段时，字段重命名必须同步改写端口绑定边，并重新计算 flow:displayLabel。端口绑定的边可通过 edge.properties['flow:displayLabel'] 提供 UI 标签覆盖，并可根据 schema endpoints 与字段类型兼容性进行校验。Node Quick Editor 数据流会在上游链路上计算 connectedValuesBySchemaPath 且不修改 GraphData；registry schemaMappings 可指定 reduceId 与 transformId 以派生映射值，auto-apply 仅在字段为空时按需或启用后填充。",
        "@language": "zh-cn"
      }
    ],
    "graphConfigsSemantics": [
      {
        "@value": "Graph configs vocabulary: grouping (schema.layout.groups.*), positioning (layout mode + flow engine knobs), collisions (bounded relax policies + schema collision knobs), timing (rAF/interval gates and bounded timeouts), and knobs (schema/config/persistence SSOT; cache-keyed when render-affecting).",
        "@language": "en-us"
      },
      {
        "@value": "图配置词汇：grouping（schema.layout.groups.*）、positioning（布局模式 + flow 引擎参数）、collisions（有界 relax 策略 + schema 碰撞参数）、timing（rAF/interval gate 与有界超时）、knobs（schema/config/persistence 的 SSOT；影响渲染时必须纳入 cache key）。",
        "@language": "zh-cn"
      }
    ],
    "orderSafeImportRender": [
      {
        "@value": "Import→render flows are order-safe and batch-aware: bulk imports coalesce change notifications; late async completions (layouts, previews, derived views) must not override the currently selected graph or viewKey. Prefer explicit request ids or monotonic revision counters for applying async results.",
        "@language": "en-us"
      },
      {
        "@value": "Import→render 流程必须具备顺序安全与批处理意识：批量导入要合并变更通知；异步任务（布局、预览、派生视图）的迟到完成不得覆盖当前选择的图或 viewKey。应优先使用显式 request id 或单调递增的 revision 计数来应用异步结果。",
        "@language": "zh-cn"
      }
    ],
    "ssotActiveGraphRenderView": [
      {
        "@value": "All render surfaces consume the same SSOT-derived active graph render view. Derivation order: keyword base → optional frontmatter filter (document mode only) → optional group collapse. Forbid per-surface re-derivation to prevent drift between Canvas, Flow overview, tables, and stats panels.",
        "@language": "en-us"
      },
      {
        "@value": "所有渲染表面必须消费同一份 SSOT 推导的 active graph render view。推导顺序：keyword 基础图 → 可选 frontmatter 过滤（仅 document mode）→ 可选 group collapse。禁止各表面自行二次推导，避免 Canvas、Flow 概览、表格与统计面板之间产生漂移。",
        "@language": "zh-cn"
      }
    ],
    "documentStructureBaselineDefault": [
      {
        "@value": "Default UX anchors to Document Structure baseline. Baseline lock forces a stable 2D baseline (D3 + Fit-to-Screen, no Pin/Zoom-to-Selection) and blocks mode switches (semantic/frontmatter, renderer, 2D/3D, selection/create) to keep Editor/Table/Canvas/Preview aligned. Zoom view keys must isolate 2D renderers to prevent cross-renderer drift.",
        "@language": "en-us"
      },
      {
        "@value": "默认体验锚定在 Document Structure 基线。baseline lock 强制稳定的 2D 基线（D3 + Fit-to-Screen，禁用 Pin/Zoom-to-Selection），并阻止模式切换（semantic/frontmatter、渲染器、2D/3D、选择/创建），以确保 Editor/Table/Canvas/Preview 内容对齐并防止跨表面漂移。Zoom view key 必须隔离不同 2D 渲染器，防止跨渲染器漂移。",
        "@language": "zh-cn"
      }
    ]
  }
}
