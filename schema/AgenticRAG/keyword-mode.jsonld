{
  "@context": "https://huijoohwee.github.io/schema/AgenticRAG/v1/context.jsonld",
  "@id": "rag:KeywordMode",
  "@type": "rag:Directive",
  "schemaVersion": "1.0.0",
  "rdfs:label": [
    { "@value": "Keyword mode graph derivation", "@language": "en-us" },
    { "@value": "关键词模式图推导", "@language": "zh-cn" }
  ],
  "rdfs:comment": [
    {
      "@value": "Directive for deriving a compact, domain-agnostic keyword graph from document text when a UI switches from document-structure mode into keyword mode. Keyword mode exposes Subject/Object/Entity keywords as nodes and Verb/Predicate/Relationship keywords as edges, with co-occurrence counts and similarity weights so the same bottom-panel dashboard can summarize nodes, edges, and communities without relying on a selection. Implementations should be deterministic, cache derived graphs by a stable text hash, and isolate layout caches across modes to prevent cross-mode cache contamination.",
      "@language": "en-us"
    },
    {
      "@value": "当 UI 从文档结构模式切换到关键词模式时，用于从文档文本推导紧凑、领域无关关键词图的指令。关键词模式将主语/宾语/实体关键词作为节点，将动词/谓词/关系关键词作为边，并提供共现计数与相似度权重，使底部面板仪表盘可在不依赖选择的情况下汇总节点、边与社区。实现应保持确定性，用稳定的文本哈希缓存推导结果，并隔离不同模式下的布局缓存以避免跨模式污染。",
      "@language": "zh-cn"
    }
  ],
  "fields": {
    "ui.semanticMode": {
      "type": "xsd:string",
      "allowed_values": ["document-structure", "keyword"],
      "description": "UI-level mode selector. document-structure renders structural nodes/edges; keyword derives a keyword graph from text for exploration and dashboarding."
    },
    "keywordMode.stopwords": {
      "type": "@json",
      "default": [],
      "description": "Optional stopwords list removed during tokenization/entity extraction (case-insensitive) to avoid noise from common function words. Default: NLTK English stopwords."
    },
    "keywordMode.minTokenLength": {
      "type": "xsd:integer",
      "minimum": 1,
      "default": 3,
      "description": "Minimum token length used when splitting text into tokens for keyword extraction."
    },
    "keywordMode.similarityMetric": {
      "type": "xsd:string",
      "allowed_values": ["ppmi"],
      "default": "ppmi",
      "description": "Similarity metric used for edge weights derived from co-occurrence statistics (positive PMI)."
    },
    "keywordMode.communityDetection": {
      "type": "xsd:string",
      "allowed_values": ["label-propagation"],
      "default": "label-propagation",
      "description": "Deterministic, lightweight community detection strategy used to map keyword graph communities onto graph layers/subgraphs."
    }
  },
  "algorithm_steps": [
    {
      "step": 1,
      "name": "Collect source text",
      "description": "Use the active document text when available; otherwise concatenate neutral node text (for example labels) to form a fallback text corpus."
    },
    {
      "step": 2,
      "name": "Extract entity keywords",
      "description": "Extract subject/object/entity keyword candidates from text spans (for example inline-code spans, capitalized phrases, identifier-like tokens, and neutral word tokens), normalize to case-insensitive keys, remove stopwords, and count mentions. Each unique entity key becomes one node with a stable id derived from the normalized key, and should expose frequency-based sizing via properties like visual:nodeSize or visual:importance."
    },
    {
      "step": 3,
      "name": "Extract relationship keywords",
      "description": "Within sentence or line blocks, pair co-mentioned entity keywords and infer a Verb/Predicate/Relationship keyword by scanning tokens between entity mentions (prefer verb-like tokens; otherwise pick the first non-stopword token; fallback to a neutral relation label when empty). Remove inferred relationship tokens from the entity-node set when they collide, aggregate relationship counts per entity pair, and select the most frequent relationship label per pair."
    },
    {
      "step": 4,
      "name": "Compute co-occurrence and similarity",
      "description": "For each block, update per-entity block counts and per-pair co-occurrence counts. Compute positive PMI scores over blocks and store as an edge weight while keeping the raw co-occurrence count; implementations should optionally map strength into renderer-friendly properties like visual:width and visual:weight."
    },
    {
      "step": 4.1,
      "name": "Support runtime scaling",
      "description": "Expose user-tunable multipliers for keyword node size and keyword edge width via schema.three.keywordNodeSizeScale and schema.three.keywordEdgeWidthScale so UIs can adjust emphasis without regenerating the keyword graph."
    },
    {
      "step": 5,
      "name": "Assign communities for graph layers/subgraphs",
      "description": "Build an undirected neighbor map from edges and run deterministic label propagation to assign compact integer community ids; store ids on nodes as visual:community and map to visual:layer so 2D subgraph groups, 3D Z-layering, and layer controls remain consistent."
    },
    {
      "step": 6,
      "name": "Cache and isolate layout",
      "description": "Cache derived graphs by stable text hash. Key layout position caches by (semanticMode, frontmatterMode, layoutMode) to prevent cross-mode cache contamination while preserving each mode’s layout stability; merge media-capable base nodes into the derived keyword graph so the media overlay toggle remains effective in keyword mode."
    }
  ],
  "neutrality": {
    "dataset_agnostic": true,
    "project_agnostic": true,
    "domain_agnostic": true,
    "notes": "Stopwords and heuristics must remain neutral and must not depend on dataset-specific vocabularies. Derived ids must be stable and deterministic to support caching, selection, and reproducible layouts."
  }
}
